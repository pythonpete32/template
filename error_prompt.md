Okay, so here's the context of the code, right? I started out with the script, right? So I went to the... I started out with the script and I went to the VM docs and I wanted to... So I wanted to test out the best way to do this, right? So I deployed a contract. Yeah, so sorry, that's where I started out. I started out by deploying the contract. I done it on base because base is like super cheap and it's one of the networks that's implemented it. Yeah, so it's implemented the EIP. Then I went to...

Okay, so once I deployed the contract I create the script, right? The batch executor script. So you can see how it works. It's pretty simple. I want you to like explain like walk through all the different stuff, right? But then of course like I wanted to implement this in React, right? Because obviously the main like the main goal is to be able to use this with like metamask or Rabi or frame or whatever externally on the count, you know, so you can do cool things like Like Do token approvals Transfers and Stuff like that all in one transaction, right? Okay. Well, we ran into our first issue

signAuthorization, So the sign authorization function doesn't work with JSON RPC accounts which is super annoying right so ie. Metamask so Metamask and all these other browser-based wallets don't I'm not supported with VM out of the box so we had to write our own function yes we had to write our own function which we did with the sign-7702-auth.ts

Next thing I did was I created the hooks to actually use that function we created. Oh, okay, before that as well, right? So, before that, like, what's the strategy here? So, now we've got this auth function. We, you know, base is super cheap, right? So we're going to be able to sponsor transactions. So what we did was we created the relayer.

Yeah, so we create the relay out as a server action because of course it's like 2025. So you know, I would recreate API routes, you know, server actions just way better for this use case. So we need as we use the server action and in the server action, we're going to use a private key on the back end. And this is going to sponsor this is going to take our authorization and our it's going to take our authorization and our encoded function calls, just like we have in the script and it's gonna we're going to pass it from the front end to this back end key. So we're going to do that and then we're going to create a new hook, we create a new hook to relay the transaction, like send it to the back end and relay that transaction. And yeah, so we just literally copy that and that's it. Basically, that's that's that's the whole thing. So this essentially like teaches you how to so the whole point of this is like now from using these basic things here now, we can build some rather complicated, some better applications right using this basic primitives here, you know, we can we can create like a dust sweeper. Right, so now we've got this the next part of it that part two is going to be like now we've got all the pieces in place afterwards. Now we've got all these bits, what we're going to do next is in part two of this, we're going to create like a dust sweeper, which is going to like take okay, yeah, actually so this is that was the original idea. The original idea was to create the dust sweeper, right? And I think that's how we should start out like so as like, why this is such a good idea? Why this is such a cool thing, right? Because like, I've got a bunch of keys. I've got a bunch of accounts that I've got like dust in them. They just doesn't make sense to approve and to transfer, right? So so yeah, so we're going to do that. We're going to create a dust sweeper with this in part two.

Okay something else that we want to do as well is you're like in between before we get started, on the front end bit, like after we've run the script like the the basic script, you want to have a look at what the transaction hash looks like, right? So we're going to um... we'll have a section for you know so we can see the reason why we wrote the smart contract like that so we can see that the address dot this is actually the um... the address dot this is actually the uh... the eoA address like the address of our account and the sender, the message dot sender, is going to be the relayer address like we want to see that in the logs in um etherscan so um... Yeah, so we're going to show that as part of the tutorial as well. All right, a screenshot.
